# Rust 所有权

## 为什么会发生内存泄漏

这里打个比方，保险柜的空间相对来说不大，可以存放一些小物件，但如果你要存放的货物太大了，就需要把它们放在仓库里，然后把货物存放的位置、货物的种类记在小本子上，放在保险柜里。如果有一天你需要这些获取，就根据小本子上记录的信息去仓库里查找，如果你想把货物卖了，只需告诉买家货物在哪里。但是，如果这个小本子被扔掉找不到了，你就不知道仓库里存放的到底哪个是你的货物，因为它们看起来都一样。

**栈**和**堆**都是程序可以访问的内存，上面说的保险柜就相当于栈，仓库就相当于堆，保险柜里的东西相当于变量，记录信息的小本子相当于指针变量。如果程序需要访问堆上的内存，就需要通过指针变量里保存的信息：内存地址和数据类型。

栈是由系统自动管理的，函数退出后这个指针变量就被销毁了，但是堆上的保存数据仍然占据着内存，时间一长，堆上全都是这种无主的数据，可用的空间就越来越少，这就是**内存泄漏**。

## 什么是所有权

对于内存泄漏，C 语言选择相信程序员有能力管理好内存，能够手动释放堆上不再需要的空间，Java 则采用垃圾回收机制，每隔一段时间就检查一下堆上是否有不再使用的空间，如果有就释放掉。二者各有优劣：前者过度依赖使用者的水平，但众所周知绝大部分使用者都是水货，它们根本管理不好内存；后者会带来额外的时间开销，让本来就缓慢蠕动的程序更慢了。

而 Rust 选择了第三条路，每个堆上的数据只能有一个拥有者，这个拥有者所在的栈帧被释放掉前，系统会将堆上的数据释放掉。这样有两个优点：

- 数据的释放是自动完成的，无需手动干预；
- 数据何时释放是在编译期就确定的，节约了垃圾回收器挨个检查所需的时间。

一句话概括：在所有权模型里，指针变量和数据的对应关系从 n 对一变成了一对一。

## 所有权转移

举个例子，将字符串`"foo"`绑定给变量`s1`：

```rust
let s1 = String::from("foo");
```

`=`表示将变量`s1`拥有的数据转移给变量`s2`：

```rust
let s2 = s1;
```

这时如果你尝试访问变量`s1`就会导致编译失败，因为`s1`已经不拥有数据了。如果你希望原来的变量继续拥有数据，可以用`.copy()`为数据创建一个副本，然后把这个副本绑定给新变量：

```Rust
let s1 = String::from("foo");
let s2 = s1.copy();
```

这时变量`s1`和`s2`拥有的是两份完全独立的数据，互不影响。

## 所有权借用

所谓**借用**就是在不转移所有权的情况下，临时获得访问数据的权利，分为**不可变借用**和**可变借用**两种。

不可变借用通过`&`创建，下面两个变量都可以读取数据，但是不能修改数据：

```Rust
let s = String::from("foo");
let s1 = &s;
let s2 = &s;
```

可变借用通过`&mut`创建，可以读取和修改数据，它有一些额外要求：

- 数据本身必须是可变的；
- 一个变量只能创建一个可变借用，并且不能存在非可变借用；

```Rust
let mut s = String::from("foo");
let s1 = &mut s;
```
